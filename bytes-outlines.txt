CompChomp Small Bytes Points

1/20 AI BREEDING HUMANS
(NL 1/22: Uppercase/Lowercase)

1/27 STAR WARS PROGRAMMING LANGUAGES
(NL 1/29: Latin Letter Modding)

2/3 ANNOUNCEMENT
(NL 2/5: Announcement)
Hello World! Hello, you! I know we're just a couple short videos into talking code (code, sex and Star Wars, you know what I means).

Keep it between us right now, but I'm proud to be the first to announce a collaboration with NativLang - you know, that language-loving channel. Well, NativLang and CompChomp got outside attention when we pitched our idea of making a few videos about where our channels meet: linguistics (NativLang's topic of choice) and code (which is obviously MY most favorite)!

We'll talk passwords, machine translation and the languaginess of programming languages (like are they... languages...?). I also want to drop some lines about lady coders.

Yeah, so the longer videos will come out over on NativLang - that's part of the deal - but we're going to keep the conversation going here, give you some love and share things I personally find most fascinating about each topic.

Make sure you're double subscribed to get both sides of these languagey programming tales. Starting in two weeks.
For next week, I have a small bytes for you about something that goes up and down and runs on code. (Waggle eyes.) CHOMP!


2/10 Byte 1 - Elevator Algorithms
(NL 2/12: 0)
In college I lived on the 26th floor. My view of the Brooklyn bridge was beautiful. The wait for the elevator in the morning...not so much. I thought that elevator was my friend. I push a button, it gets me to calss on time. But no. This elevator had a mind of its own... an algorithm. That's right, elevators run on code.

Welcome to CompChomp, the only show on the internets where pressing all 102 buttons in the Empire State building elevator is research, not a social faux pas.

That elevator I was waiting for in New York probably works like most grunt elevators do. It knows two things: where it is and where it's going. It gets its current location from sensors. It uses buttons to know where it's heading. Lots of buttons. The buttons on every floor and the buttons inside each elevator all hook into one computer brain. The elevator algorithm tells it to go in one direction until it can't anymore, and only then can it switch. So, guess what? I'm on the 26th floor and pressing down. And I swear it's usually on the 25th floor and already heading down, all the way down. And I have to wait for it to come full circle.
(http://science.howstuffworks.com/transport/engines-equipment/elevator7.htm)

But let's say you're an eccentric bazillionaire who dreams of building a building WAY taller than anything in New York? You need some real elevator brains to pull that off. Which is why our simple algorithm wasn't good enough for mega tower Burj Khalifa in Dubai. Those use a destination dispatch strategy. Now I should say we didn't dig up too many specifics - like a lot of code, these are proprietary inventions. (Secret sauce.) But you go to a keypad and tell the elevator what floor you're going to. Then the computer thinks about all the elevators it's got and all the calls it's got meaning where everyone is and where everyone's going. And it determines which elevator can get you there in the shortest amount of time. It gives you an elevator assignment. When you get in that elevator, there might not even be a single button. You just - zip - bbffft! - floor! 

This thing is making decisions as a whole interconnected system. It's not just every elevator for itself in here! Also, you're not getting grouped with passengers going to totally different parts of the building. That really stands out to me - you're not grouped by your PICKUP location but by your DESTINATION. (Put me in a box, ey? Floor 127, whut whuuut!?!)
(http://www.npr.org/templates/story/story.php?storyId=122457774)

So this is the future, less of your life spent waiting for that elevator. Thanks to smalgorithms like these and all the other fun code you're subscribed for! You are subscribed, right? Anyway, I guess you'll have less chances to give your elevator pitch to the suits upstairs. (Heh, I got in so much trouble once for calling some executives suits. Not in a elevator though.) CHOMP!


2/17 Computers Speak A Strange Language
(NL 2/19: Are Programming Languages Really Languages?)
Hello World! So one day I'm getting my philosophy on, trying to understand some deep thoughts about justice and the universe, when I turn the page and the book stops speaking English. (Will it English? No, no it won't.) Out of nowhere it was all weird mathy symbols, backwards E, A to the x to the scary arrows therefore Justice! So I did what any reasonable human would. Panic, close that book and hide the evidence. (When language starts looking like math, I am outta there so fast.) But you know what? Now I'm a coder, and that terrifying moment was way more relevant to my career than I ever could have imagined. Freaking logic.

Welcome to CompChomp, the only show on the internets where for all x where x is a world, I say hello to x.

That surprise logic hiding in my philosophy book wasn't frustrating because I'm afraid of math and science and logic. (I'm a guurrrl and I hate math! No.) It was because I didn't expect them to be there. I lived in a world where you have language and history and big ideas on one side. And on the other side across a huge chasm - (I think I used to say "tchasm", don't laugh at me) - was numbers and data. And the two didn't mix! But then the walls came down.

If I weren't blinded by the trauma, I could've appreciated my first taste of what's known as a formal language. (It's when math and language have a hideous love child. That may not be the exact definition.)

I don't want to get all into formal languages. That book still haunts me. But I will say one thing. About this man. (Look... at that... HAIR!!) So Leibnitz - mathematician, polymath and wig-wearer extraordinaire - this guy got appointed as courtier to the royal Duchy of the House of Brunswick (I think I got that right - I'm not European. But I do feel quite regal.) And though his fancy employers grumbled, he spent his time coming up with logic. (Bet that makes you feel bad about your side projects!) He discovered that all of our ideas were made of small pieces that we build up into complex statements. That's almost computery - so close, just missing the machine, bigwig.

Thanks to his logic, we can connect any two ideas with an operator to make one of his complex statements. I mean we can say cookies and ice cream, or dogs and cats, or x and y, and that AND always works the same way - if we have both of them, it's true. If we don't, it's false. (You lied to me! I mean if I turn up and you promised puppies and kittens and there are only puppies, you got some splaining to do.) You should have said OR. Which is another operator. Like connecting X OR Y. Only one has to be there for it to be true. But, getting all logicky on you here. What if both of them are there? What if there are puppies and kittens and you told me there would be puppies OR kittens? Well, it's still TRUE! That's how OR works. It's only false when both of them aren't there. I just laid some logic on you.

And you know what else works exactly like that? Seriously, these are all the same in code. Yep, just like logic, programming languages are formal languages.

So as we saw in my collaboration over on NativLang - (are programming languages real languages?) - natural languages aren't the only way to be a language. If I'd kept that book open, I would have learned that lesson a bit sooner. But whatever. I'll see you next week. And remember. Comment OR subscribe! Ahahaha... hah. CHOMP!


2/24 Thoughts on Passwords
(NL 2/26: Why Passwords Stopped Being Words)
Stop using real words for your password. Because real words are hackable. Don't believe me? Well here's how a really dedicated hacker will guess your password using nothing but brute force.

Welcome to CompChomp, the only show on the internets where welcome to CompChomp, the only show on the internets where... whew, sorry, I got stuck in a loop there!

Brute force isn't the punchline to a bad joke. It's a way to solve problems. My favorite way. Try everything! Try everything!!

I'm a brute. And I want to guess your password. So I go through the letters in your alphabet - I mean "loop" through your alphabet. Hah, such a clever term for it. (You know code jargon gets confusing, but I like loopies.)

I'll pull out the brute forcer's tool of choice: a for loop. For every letter, I'll guess that letter. So from a to z, I guess 'a' and then 'b' and then 'c'... I think you see what's going on here.

But that for loop left me with 26 one-letter hacks. I want more letters! So for every letter, I pair it with every other letter. Wow. 'aa', 'ab'. Yeah, that's all possible two letter words. Another for loop, and that's all possible three letter words. And all three letter nonsenses too, because it's guessing every combination - actually, every permutation - (I'm a nerd I say things like, uhm, technically combinations are not the same as permutations).

Keep shoving for loops one inside of the other. (I mean, ahem, nesting them.) That's all possible guesses for as long of a word as there are nested loops in this mess. (Look, loops keep going in and in like a triangle. It's a code triangle!!=D)

What a headache though. I'm guessing, 26 times. And 26 times 26 times. And 26 times 26 times 26 times... yeah, it's a lot of calculations. That means a lot of time. And time costs us - but that's Big-O, it's for another time. (BIG-OOOO.)

That's all it takes. If your password is "dragon" or "monkey" or - ahem - "password", you're done. But in my collab with NativLang, we see why, thanks to human language, hackers don't even need this slow brute-force stuff. (Hey! Don't call me slow! I brute force all my problems!) But we coders do love ourselves some for loops. Life lesson. CHOMP!

3/2 Stallman And Passwords

X 	text: q mark - eccentric man Stallman shadow w/ question mark
X 	img: pwd - password business before it got off the ground
X 	img: comp + unlocked - computers but no passwords
X 	img: floppy disk
X 	anim: CTSS -> Compatible Time-Sharing System
X 	anim: green txt, black box, cursor blink for PASSWORD turn off print
X 	img: ARPANET - wild west of the internet
X 	img: all the Stallman series
X 	img: Stallman comp back with green light emanating
X 	img: open access lock - people from outside could access ARPANET
X 	img: broken computer - new computer system
X 	text: empty string ""
X 	text: "rms"
X 	img: quote - everyone should set to ""
X 	text: "rms" "rms"
X 	img: suit reacts
X 	img: 2 suits react
X 	img: 3 suits react + fuming

Nobody likes passwords. And that's nothing new. In 1977 one particularly eccentric MIT man pulled out all the stops to kill this password business before it ever got off the ground. That's right, let's roll the clock back to the days when there were computers... but no passwords!

(intro)

Welcome to CompChomp, the only show on the internets where even if you don't believe in Open Source, Open Source believes in you.

Once upon a floppy disk ;), if you were smart enough to punch in commands, you had access to all the info on a computer. But then came MIT's time-sharing system, CTSS. So advanced. So secure. You would type in the keyword PASSWORD, and then it knew to turn off printing to the screen while it let you type in your secrets.

That's cute. But it was still the Wild West of computers and intranets, and some pretty major stuff was left unsecure. Once people decided to zip up these early systems, they faced sly resistance.

From Richard Stallman. He was working as a hacker in the MIT AI computer lab. That's right - their lab really was run by hackers. (Josh, change my resume! I want that title.) And the hackers had a 'tourist' policy: people from outside MIT could log on to their computers to access DARPAnet.
	
But a new sheriff came to town. Well, a new computer system. Less of a town sheriff, more like a town... horse surgeon... with bad tremors. (Whew, got lost in my own metaphor. Simile? Whatever.) Yeah, it crashed - a lot. But the people in charge didn't fix the buggy, unreliable hardware. Nope. They revoked the 'tourist' policy and required everyone to have a password. (Typical suits.)

No problem for Stallman! He set his to the empty string so people could continue logging on with his credentials "rms". But, get this guy, he had to take it to the next level. He decrypted everyone's passwords and messaged them with their password and a suggestion to change it to the empty string. About 20% complied.

Game on. 'The Man' responded by requiring that the password be something other than an empty string. Stallman counters: he sets his password to match his login. 'rms' 'rms'.

By this point I'm sure they were fuming. They changed the requirements AGAIN so that people would be forced to have passwords that were different than their logins. And so, Stallman had one last move: he flat-out refused to use the system any longer.

That was the core of it for him - this wasn't just about passwords. Stallman had - and has - some strong opinions about open access. This thing about only giving certain people access to certain information was not his style. It's a whole philosophy man. Freedom. Yeah... CHOMP!  


3/9 Thoughts on MT
(NL 3/4: How Computers Failed At Russian: History of Machine Translation)
In the Cold War, computers were trying - and failing - to translate between Russian and English. I explored the American side of that frustrating early history of machine translation, but what were the Russians doing?

Welcome to CompChomp, the only show on the internets where we like our sugars natural and our languages artificial.

In my collaboration with NativLang, we met the major players in the early computer translation boom in the US: the Perfectionists who were like "rules! teach computers how language works!" And then the Brute Forcers who said "no! data! let computers figure it out on their own!"

Meanwhile, the Russians were making things even more complicated. Stalinist Russia had been standing in the shadow of a technology ban. (Teach good theory! Use good tech!) But with Stalin’s death in 1953 and news of that successful tech demo in 1954, Russians got in on the translation game.

Americans were mainly using a “direct translation” approach: take a source language and figure out how to rewrite its words in a target language. Lazy Americans. This was way too simple for Russia - translating between two languages - hah! no! Why not THREE at once!?

Leningrad University’s Andreev built up a middle language that sits between the source and target pair. This in-between language, "interlingua" in Latin, had features common to many languages. The interlingua was a real made-up language - (oxymoron?) - I mean it was really, really made up, like with its own sentence structure and its own word grammar.

Hah, I'm giving Russia a hard time here. But using a third language wasn't such a bad idea. When you pick a language pair to translate between in your favorite web translator, it's using an intermediate "pivot language" - English.

Anyhow, in telling the tale of the birth of early machine translation to its death in that cold AI Winter, I felt the Russian side of things needed some attention. C'mon, you can't talk Cold Wars and winters and not mention what's going down in Russia. CHOMP!


3/? Thoughts on Disappearing Female Developer
(NL 3/11: The Disappearing Female Developer)
- more on mentorship?

3/16 Byte 2 - ???
(NL 3/18: 0)