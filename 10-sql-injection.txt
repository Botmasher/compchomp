Growing up - the internet was my constant companion.  When I was really young, I would dial directly into my favorite Bulletin Board Systems (BBS) to play games and chat. As I got older, things got easier and I used companies like Prodigy, CompuServe and AOL to get online. As I was finishing up high school, the old slow dial up internet access transitioned into broadband access and the rest was history.  But something else was happening around this time...something that seemed so innocent and yet it would prove to be one of the greatest vulnerabilities the internet had ever seen.  What was it?  Why, the transition to SQL databases.  Duhn...duhn...duhn.....

[INTRO]

Welcome to CompChomp...the only show on the internet where doing more than one thing at a time is bad....very bad.

In the late 90's, developers of web applications were starting to transition from Access databases to SQL databases.  In 1998, Jeff Forristal, a hacker known as Rainforest Puppy (Hey Josh!  I want a cool hacker name!), discovered that SQL databases allowed batch commands.  You could open up the connection to the database once then send multiple commands through.  NBD because multitasking is good, right?  However, when you have input coming from outside users heading straight into your database...well, things get a little dicy.  

A shady character...like this one....could user your innocent little web form to gain access to parts of your database you didn't want them to have by piggy backing their own SQL requests onto your intended request....like so.

You kindly provide your users with the ability to search for a restaurant even when they only know part of the name:

SELECT "restaurant".* FROM "restaurants" WHERE ("name LIKE '%user_input%');

And shady mcshadester searches for the following restaurant (which doesn't sound so great to me):

'); DELETE FROM Restaurants --

Which gives us the following SQL query:

SELECT "restaurant".* FROM "restaurants" WHERE (name LIKE '%'); DELETE FROM Restaurants -- %â€™)

And, suddenly, your entire restaurant table is gone....not your table at the restaurant...your restaurant table in your database.  Though you should probably cancel those reservations because you're going to be spending the rest of the night restoring your database from backups.

This nasty little trick is known as SQL injection.  It's when someone closes out a legitimate transaction with your database then immediately sneaks more SQL commands in there so they can interact with your database in a way you didn't intend.

SQL injection has been on people's radar for at least 18 years and yet it regularly ranks at the top of the Open Web Application Security Project's 10 most critical web application security risks....and that is not a top 10 list you want to be on.  If you do a quick scan of recent news, you'll get plenty of examples of SQL injection in action:

June 2011, a major entertainment conglomerate lost the data of over 1,000,000 users, including passwords that were reportedly stored in plain text.  Ouch!

October of 2012, SQL injection is used to steal the personal records of thousands of students from 53 top universities around the world.  Student info is highly sought after because they usually have great credit records and they don't watch their credit scores.  I guess that's one positive side effect of crushing student debt...by the time you graduate, no one wants to steal your identity.

In August 2014, hackers in Russian stole 1.2 billion username and password combinations and 500,000 email addresses from 400,000 sites.  Not just small sites made by your cousin's best friend's uncle's kid who sort of knows how to code.  This hack included sites built by Fortune 500 companies.

More recently in November 2015, an electronic toy company was hacked and the personal data of 5 million parents and 200,000 kids was taken.

So what's the deal, is there some elite Hacker Havard out there teaching the world's greatest hackers how to sneak unwanted SQL commands into our databases like sneaky little code ninja?

In a word....nope.

SQL injection is common for two reasons.

The first is that it's easy to automate.  There are scripts you can buy that will just bounce around the internet testing web forms and URLs to see which ones are vulnerable.  Once a site is found, the same basic techniques can be used to get access to your data.  Troy Hunt (a web security expert and founder of haveibeenpwned.com) actually has a video showing him teaching his then 3-year-old to do a SQLi attack using one of the most popular programs.  This thing has a gui and everything...you don't even have to know how to use the command line!

The second is that it keeps working.  Hackers continue to use it because even though we've known about it for 18 years, they're still getting gigs and gigs worth of valuable personal data from our web apps.

So, how do we put an end to this?  

If you're a programmer, you can make sure that user-provided data is never sent directly to your database.  It should always be sanitized first so none of the characters that have special meaning to SQL databases are treated as anything other than a string.  If your setup allows for it, you can also use parameterized queries.  This allows the statement to be sent to the database with placeholders for the user data so the database can determine what type of functions it will need to run.  Then, when the statement comes back with the data supplied by the user, if the user's input changes the functions that need to run, the database will throw an error and won't make the changes.

Is there anything you can do if you're not a programmer?  As lame as this might sound, one of the best defenses is to have a solid password (no more using password123) and to use different passwords for each site.  This way, if one site you're on is hacked, those shady hackers won't immediately have access to all of your other sites as well.  It won't really stop SQL injection but it will keep you from losing everything just because the dog walking app you used once didn't protect your data.

CHOMP!
